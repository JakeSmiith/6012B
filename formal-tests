# app.R
library(shiny)
library(readxl)
library(dplyr)
library(lubridate)
library(zoo)
library(timeDate)
library(tidyr)
library(purrr)
library(broom)
library(boot)
library(DT)

# ────────────────────────────────────────────────────────────────────────────────
# GLOBAL: load & compute results
# ────────────────────────────────────────────────────────────────────────────────

file_path  <- "C:/Users/jakes/Downloads/quantum_and_index_volumes.xlsx"
sheets     <- excel_sheets(file_path)
event_date <- as_date("2025-01-08")
window_days<- c(5,20,60)
stocks     <- c("IONQ","QBTS","RGTI")
indexes    <- c("CCMP","RTY")
metrics    <- c("ret","volume_pct","vol_change")

# robust loader
read_and_clean <- function(sheet) {
  df <- read_excel(file_path, sheet = sheet) %>%
    select(where(~!all(is.na(.))))  # drop empty cols

  # normalize names
  names(df) <- names(df) %>% tolower() %>% gsub("[^a-z0-9]+","_",.)

  # find date column
  date_col <- grep("^date$", names(df), ignore.case=TRUE, value=TRUE)[1]
  if (is.na(date_col)) stop("No date col in ", sheet)

  # find numeric cols except date
  num_cols    <- names(df)[sapply(df, is.numeric)]
  numeric_only<- setdiff(num_cols, date_col)
  if (length(numeric_only) < 2) stop("Not enough numeric cols in ", sheet)

  # pick volume
  vol_cand   <- grep("vol", numeric_only, ignore.case=TRUE, value=TRUE)
  volume_col <- if (length(vol_cand)) vol_cand[1] else numeric_only[1]

  # pick price
  price_cand <- grep("price|last|close", numeric_only, ignore.case=TRUE, value=TRUE)
  price_col  <- if (length(price_cand)) price_cand[1] else setdiff(numeric_only,volume_col)[1]

  df %>%
    rename(
      date   = all_of(date_col),
      volume = all_of(volume_col),
      price  = all_of(price_col)
    ) %>%
    mutate(
      date   = as_date(date),
      symbol = sheet
    ) %>%
    arrange(date) %>%
    distinct(date, .keep_all=TRUE)
}

# read + bind
df_all <- map_dfr(sheets, read_and_clean)

# compute metrics
df_all <- df_all %>%
  group_by(symbol) %>% arrange(date) %>%
  mutate(
    ret        = log(price/lag(price)),
    volume_pct = volume/lag(volume) - 1,
    real_vol   = rollapply(ret, 20, sd, align="right", fill=NA),
    vol_change = real_vol - lag(real_vol)
  ) %>%
  ungroup()

# bootstrap helper
boot_diff_mean <- function(dat,i) mean(dat[i,2] - dat[i,1], na.rm=TRUE)

# build result table
results <- expand_grid(
  stock  = stocks,
  index  = indexes,
  metric = metrics,
  window = window_days
) %>%
  mutate(
    pairs = pmap(
      list(stock,index,metric,window),
      function(stock,index,metric,window) {
        pre_s  <- df_all %>% filter(symbol==stock, 
                                     date>=event_date - days(window), 
                                     date< event_date) %>%
                  select(date,val_s=all_of(metric))
        pre_i  <- df_all %>% filter(symbol==index, 
                                     date>=event_date - days(window), 
                                     date< event_date) %>%
                  select(date,val_i=all_of(metric))
        post_s <- df_all %>% filter(symbol==stock,
                                     date>=event_date, 
                                     date< event_date+window) %>%
                  select(date,val_s=all_of(metric))
        post_i <- df_all %>% filter(symbol==index,
                                     date>=event_date, 
                                     date< event_date+window) %>%
                  select(date,val_i=all_of(metric))
        pre_df  <- inner_join(pre_s, pre_i,  by="date")
        post_df <- inner_join(post_s, post_i, by="date")
        list(
          pre  = pre_df$val_s  - pre_df$val_i,
          post = post_df$val_s - post_df$val_i
        )
      }
    )
  ) %>% unnest_wider(pairs) %>%
  mutate(
    ttest   = map2(pre, post, ~ t.test(.x, .y, var.equal=FALSE)),
    wilcox  = map2(pre, post, ~ wilcox.test(.x, .y, exact=FALSE)),
    bootobj = map2(pre, post, ~ boot(cbind(.x,.y), statistic=boot_diff_mean, R=2000))
  ) %>%
  mutate(
    t_stat   = map_dbl(ttest,  "statistic"),
    t_p      = map_dbl(ttest,  "p.value"),
    w_p      = map_dbl(wilcox, "p.value"),
    ci_lower = map_dbl(bootobj,~ tryCatch(boot.ci(.x,type="perc")$percent[4], error=function(e) NA_real_)),
    ci_upper = map_dbl(bootobj,~ tryCatch(boot.ci(.x,type="perc")$percent[5], error=function(e) NA_real_))
  ) %>%
  select(stock,index,metric,window,t_stat,t_p,w_p,ci_lower,ci_upper)

# ────────────────────────────────────────────────────────────────────────────────
# UI
# ────────────────────────────────────────────────────────────────────────────────

ui <- fluidPage(
  titlePanel("Event‐Study: Quantum Stocks vs. Index Pre/Post Jan 8"),
  sidebarLayout(
    sidebarPanel(
      selectInput("stock","Stock:", choices=stocks,   multiple=TRUE, selected=stocks),
      selectInput("index","Index:", choices=indexes, multiple=TRUE, selected=indexes),
      selectInput("metric","Metric:",choices=metrics,multiple=TRUE,selected=metrics),
      checkboxGroupInput("window","Window (days):",choices=window_days,selected=window_days)
    ),
    mainPanel(
      DTOutput("table")
    )
  )
)

# ────────────────────────────────────────────────────────────────────────────────
# SERVER
# ────────────────────────────────────────────────────────────────────────────────

server <- function(input, output, session) {
  filtered <- reactive({
    req(input$stock, input$index, input$metric, input$window)
    results %>%
      filter(stock  %in% input$stock,
             index  %in% input$index,
             metric %in% input$metric,
             window %in% input$window)
  })
  output$table <- renderDT({
    datatable(filtered(),
              rownames=FALSE,
              options=list(pageLength=10,autoWidth=TRUE),
              caption=htmltools::tags$caption(
                style='caption-side: bottom; text-align: left;',
                't_p = Welch p-value, w_p = Wilcoxon p-value'
              ))
  })
}

# ────────────────────────────────────────────────────────────────────────────────
shinyApp(ui, server)
