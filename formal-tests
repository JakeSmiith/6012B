library(shiny)
library(readxl)
library(dplyr)
library(lubridate)
library(boot)
library(DT)

# ────────────────────────────────────────────────────────────────────────────────
# 1) PARAMETERS & HELPERS
# ────────────────────────────────────────────────────────────────────────────────
file_path   <- 'C:/Users/jakes/Downloads/quantum_and_index_volumes.xlsx'
event_date  <- as_date('2025-01-08')
window_days <- c(5, 20, 60)
stocks      <- c('IONQ', 'QBTS', 'RGTI')
indexes     <- c('CCMP', 'RTY')

boot_mean <- function(x, i) mean(x[i], na.rm = TRUE)

# ────────────────────────────────────────────────────────────────────────────────
# 2) LOAD & CLEAN each sheet
# ────────────────────────────────────────────────────────────────────────────────
read_and_clean <- function(sheet) {
    df <- read_excel(file_path, sheet = sheet) %>%
        select(where(~ !all(is.na(.)))) %>%
        set_names(~ tolower(gsub('[^a-z0-9]+', '_', .x)))
    
    date_col     <- grep('^date$', names(df), ignore.case = TRUE, value = TRUE)[1]
    numeric_cols <- setdiff(names(df)[sapply(df, is.numeric)], date_col)
    if (is.na(date_col) || length(numeric_cols) < 2) {
        stop(glue::glue("Sheet '{sheet}' needs 'date' + ≥2 numerics; found date='{date_col}' and nums={paste(numeric_cols, collapse=',')}"))
    }
    
    df %>%
        rename(
            date   = all_of(date_col),
            price  = all_of(numeric_cols[1]),
            volume = all_of(numeric_cols[2])
        ) %>%
        mutate(
            date   = as_date(date),
            symbol = sheet
        ) %>%
        arrange(date) %>%
        distinct(date, .keep_all = TRUE)
}

sheets <- excel_sheets(file_path)
safe   <- purrr::map(sheets, purrr::safely(read_and_clean))
errs   <- purrr::keep(safe, ~ !is.null(.x$error))
if (length(errs)) {
    msgs <- purrr::imap_chr(errs, ~ glue::glue("{sheets[.y]}: {.x$error$message}"))
    stop('Load errors:\n', paste(msgs, collapse = '\n'))
}
df_all <- purrr::map_dfr(safe, 'result')

# ────────────────────────────────────────────────────────────────────────────────
# 3) COMPUTE daily log-returns
# ────────────────────────────────────────────────────────────────────────────────
df_all <- df_all %>%
    group_by(symbol) %>%
    arrange(date) %>%
    mutate(ret = log(price / lag(price))) %>%
    ungroup()

stock_ret <- df_all %>%
    filter(symbol %in% stocks) %>%
    select(date, stock = symbol, stock_ret = ret)

index_ret <- df_all %>%
    filter(symbol %in% indexes) %>%
    select(date, index = symbol, idx_ret = ret)

# ────────────────────────────────────────────────────────────────────────────────
# 4) ESTIMATE market-model α, β & σ per (stock, index)
# ────────────────────────────────────────────────────────────────────────────────
est_end   <- event_date - days(2)
est_start <- est_end   - days(250)

params <- expand_grid(stock = stocks, index = indexes) %>%
    mutate(
        data_fit = purrr::map2(stock, index, ~ {
            df_s <- stock_ret %>% filter(stock == .x, date >= est_start, date <= est_end)
            df_i <- index_ret %>% filter(index == .y, date >= est_start, date <= est_end)
            inner_join(df_s, df_i, by = 'date')
        }),
        fit   = purrr::map(data_fit, ~ lm(stock_ret ~ idx_ret, data = .x)),
        alpha = purrr::map_dbl(fit, ~ coef(.x)[1]),
        beta  = purrr::map_dbl(fit, ~ coef(.x)[2]),
        sigma = purrr::map_dbl(fit, ~ summary(.x)$sigma)
    ) %>%
    filter(purrr::map_int(data_fit, nrow) >= 30) %>%
    select(stock, index, alpha, beta, sigma)

# ────────────────────────────────────────────────────────────────────────────────
# 5) BUILD AR series explicitly by (stock, index)
# ────────────────────────────────────────────────────────────────────────────────
ar_df <- params %>%
    pmap_dfr(function(stock, index, alpha, beta, sigma) {
        df_s <- stock_ret %>% filter(stock == stock)
        df_i <- index_ret %>% filter(index == index)
        inner_join(df_s, df_i, by = 'date') %>%
            transmute(
                stock,
                index,
                date,
                AR = stock_ret - (alpha + beta * idx_ret)
            )
    })

# ────────────────────────────────────────────────────────────────────────────────
# 6) COMPUTE CARs & TEST STATISTICS (Patell’s Z & Corrado’s rank)
# ────────────────────────────────────────────────────────────────────────────────
results <- params %>%
    crossing(window = window_days) %>%
    rowwise() %>%
    mutate(
        sc = stock,
        ix = index,
        
        df_win = list(
            ar_df %>%
                filter(stock == sc, index == ix, date >= event_date) %>%
                arrange(date) %>%
                slice_head(n = window)
        ),
        
        n_obs     = nrow(df_win),
        ARs       = list(df_win$AR),
        CAR       = sum(ARs, na.rm = TRUE),
        boot      = if (n_obs >= 2) list(boot(ARs[[1]], boot_mean, R = 2000)) else list(NULL),
        patell_z  = if (n_obs >= 1) CAR / (sigma * sqrt(n_obs)) else NA_real_,
        patell_p  = if (n_obs >= 1) 2 * (1 - pnorm(abs(patell_z))) else NA_real_,
        
        corrado_z = if (n_obs >= 1) {
            df_est <- ar_df %>%
                filter(stock == sc, index == ix, date >= est_start, date <= est_end)
            
            m <- n_obs
            n <- nrow(df_est)
            combined <- c(df_est$AR, df_win$AR)
            ranks    <- rank(combined, ties.method = 'average')
            r_event  <- ranks[(n + 1):(n + m)]
            
            (sum(r_event) - m * (length(combined) + 1) / 2) /
                sqrt(m * n * (length(combined) + 1) / 12)
        } else NA_real_,
        corrado_p = if (!is.na(corrado_z)) 2 * (1 - pnorm(abs(corrado_z))) else NA_real_,
        
        # updated CI logic: try multiple types and fallback
        ci_vals = list(
            tryCatch({
                ci_all <- boot.ci(boot[[1]], type = c('perc','bca','basic'))
                if (!is.null(ci_all$percent)) return(ci_all$percent[c(4,5)])
                if (!is.null(ci_all$bca))    return(ci_all$bca[c(4,5)])
                if (!is.null(ci_all$basic))  return(ci_all$basic[c(4,5)])
                c(NA_real_, NA_real_)
            }, error = function(e) c(NA_real_, NA_real_))
        ),
        ci_lo = ci_vals[[1]][1],
        ci_hi = ci_vals[[1]][2],
        sample_AR = list(round(ARs[[1]][1:min(5, n_obs)], 4))
    ) %>%
    ungroup() %>%
    select(
        stock, index, window, n_obs, CAR,
        patell_z, patell_p,
        corrado_z, corrado_p,
        ci_lo, ci_hi,
        sample_AR
    )

# ────────────────────────────────────────────────────────────────────────────────
# 7) SHINY: UI + SERVER
# ────────────────────────────────────────────────────────────────────────────────
ui <- fluidPage(
    titlePanel('Market‐Model Event‐Study: Patell’s Z & Corrado’s Rank'),
    sidebarLayout(
        sidebarPanel(
            selectInput('stock', 'Stock:', choices = unique(results$stock), multiple = TRUE, selected = unique(results$stock)),
            selectInput('index', 'Index:', choices = unique(results$index), multiple = TRUE, selected = unique(results$index)),
            checkboxGroupInput('window', 'Window (days):', choices = window_days, selected = window_days)
        ),
        mainPanel(
            DTOutput('table'),
            hr(),
            h4('Diagnostics:'),
            verbatimTextOutput('diag')
        )
    )
)

server <- function(input, output, session) {
    filtered <- reactive({
        df <- results %>%
            filter(stock  %in% input$stock,
                   index  %in% input$index,
                   window %in% input$window)
        validate(need(nrow(df) > 0, 'No rows match your filters—expand your selection.'))
        df
    })
    
    output$table <- renderDT({
        datatable(
            filtered() %>% mutate(sample_AR = sapply(sample_AR, paste, collapse = ', ')),
            rownames = FALSE,
            options = list(pageLength = 10, autoWidth = TRUE),
            caption = htmltools::tags$caption(
                style = 'caption-side:bottom; text-align:left;',
                paste(
                    'n_obs = # of AR days;','CAR = cumulative abnormal return;',
                    'patell_z/p = Patell’s Z stat/p;','corrado_z/p = Corrado’s rank stat/p;',
                    'ci_lo/ci_hi = bootstrap 95% CI;','sample_AR = first 5 AR values'
                )
            )
        )
    })
    
    output
    diag <- renderPrint({
        cat('PARAMS (stock,index,α,β,σ):\n')
        print(params)
        cat('\nRESULTS rows:', nrow(results), ' (should be ', nrow(params)*length(window_days), ')\n', sep = '')
    })
}

shinyApp(ui, server)
